'''

视频：https://www.youtube.com/watch?v=tAlQxFvak2U
这个视频里面举的例子可以帮助理解


由于我们只关心奇偶性，并不关心每一个元音字母具体出现的次数。因此我们可以使用奇偶状态来表示，由于只有两个状态，我们考虑使用位运算。

我们使用 5 位的二进制来表示以 i 结尾的字符串中包含各个元音的奇偶性，其中 0 表示偶数，1 表示奇数，并且最低位表示 a，然后依次是 e，i，o，u。
比如 10110 则表示的是包含偶数个 a 和 o，奇数个 e，i，u，我们用变量 cur 来表示。

为什么用 0 表示偶数？1 表示奇数？

其实这个解法还用到了一个性质：
如果两个数字奇偶性相同，那么其相减一定是偶数。
如果两个数字奇偶性不同，那么其相减一定是奇数。
看到这里，我们再来看上面抛出的问题为什么用 0 表示偶数？1 表示奇数？。因为这里我们打算用异或运算，而异或的性质是：
如果对两个二进制做异或，会对其每一位进行位运算，如果相同则位 0，否则位 1。这和上面的性质非常相似。

上面说奇偶性相同则位偶数，否则为奇数。因此很自然地用 0 表示偶数？1 表示奇数会更加方便。
'''

class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        cache = {
            'a': 1,  # 00001
            'e': 2,  # 00010
            'i': 4,  # 00100
            'o': 8,  # 01000
            'u': 16, # 10000
        }
        # 也就是说，一共有 32 种 state

        seen = {0: -1},  # 初始化为 -1 ，由于 index 从 0 开始，而我们计算的是个数
        res = 0
        cur = 0  # 初始化元音个数为 0: 00000

        for i in range(len(s)):
            if s[i] in cache:
                cur ^= cache[s[i]]  # 判断当前的 state xxxxx 是否曾经出现过
            if cur in seen:
                res = max(res, i-seen[cur])
            else:
                seen[cur] = i
        return res
